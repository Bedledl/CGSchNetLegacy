from typing import Union, List, Dict

import torch
from schnetpack import properties
from schnetpack.md import System
from schnetpack.md.calculators import SchNetPackCalculator
from schnetpack.md.neighborlist_md import NeighborListMD


class SchNetPackCalcIPU(SchNetPackCalculator):
    def __init__(
            self,
            model_file: str,
            force_key: str,
            energy_unit: Union[str, float],
            position_unit: Union[str, float],
            neighbor_list: NeighborListMD,
            energy_key: str = None,
            stress_key: str = None,
            required_properties: List = [],
            property_conversion: Dict[str, Union[str, float]] = {},
            script_model: bool = False,
    ):
        super(SchNetPackCalcCPU, self).__init__(
            model_file,
            force_key,
            energy_unit,
            position_unit,
            neighbor_list,
            energy_key,
            stress_key,
            required_properties,
            property_conversion,
            script_model
        )
        self.idx_i = None
        self.idx_j = None
        self.offsets = None

        self.steps = 0
        self.d = 0

    def calculate(self, system: System):
        """
        Main routine, generates a properly formatted input for the schnetpack model from the system, performs the
        computation and uses the results to update the system state.

        This method overwrites the SchNetPackCalculator Method with the exact same logic,
        except, that the inference is calculated by calling the PoplarExecutor, generated by pytorch.inferenceModel.
        In this way the inference is calculated on the IPU instead of the CPU.

        Args:
            system (schnetpack.md.System): System object containing current state of the simulation.
        """
        inputs = self._generate_input(system)
        self.results = self.model(inputs)
        self._update_system(system)

    def _generate_input(self, system: System) -> Dict[str, torch.Tensor]:
        inputs = super(SchNetPackCalcIPU, self)._generate_input(system)
        inputs[properties.n_molecules] = system.n_molecules

        return inputs

    def to(self, device):
        new_self = super(SchNetPackCalcIPU, self).to(device)
        new_self.neighbor_list = new_self.neighbor_list.to(device)
        return new_self
